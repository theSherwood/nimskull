<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Mid-end intermediate representation</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Mid-end intermediate representation</h1>
    <div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
This document is a work in progress.</div>

<h1 id="purpose">Purpose</h1><p>The MIR is designed and meant to be used as a target-independent intermediate representation for analysis, transformations, and lowerings. It is centered around operations, control-flow, and locations.</p>
<p>In the compilation pipeline, the MIR is located after semantic analysis and high-level transformation (<tt class="docutils literal"><span class="pre">transf</span></tt>) but before code-generation.</p>

<h1 id="overview">Overview</h1><p>For reasons of flexibility, modularity, and since the MIR eventually should support type lowering, it is itself type agnostic: no knowledge of the types is required in order to reason about the semantics of MIR code.</p>
<div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
While this eventually should be the case, it is currently not entirely true. To know whether a conversion is an lvalue conversion or not, looking at both the source and destination type is required</div>
<p>Currently, <tt class="docutils literal"><span class="pre">PType</span></tt>s are required for representing the type of nodes, but the plan is to use an ID (handle) centered design where what the ID refers to is up to the MIR's user.</p>
<p>Even though the control-flow primitives are simpler and more regular than the ones used by the higher-level AST, they're still fairly high-level. For example, constructs like <tt class="docutils literal"><span class="pre">try</span></tt> and <tt class="docutils literal"><span class="pre">case</span></tt> statements still exist. The reason for this is twofold:</p>
<ul class="simple"><li>due to the code-generators still operating on <tt class="docutils literal"><span class="pre">PNode</span></tt> AST, the MIR code has to be translated back to it. Translating low-level control-flow primitives such as 'goto's back into 'if', 'block', and 'break' is fairly involved and would also introduce additional overhead to the back-translation</li>
<li>some transformation passes currently using the MIR are simpler to implement with access to first-class control-flow constructs such as 'try-finally'</li>
</ul>
<p>The goal is to eventually also have low-level primitives like 'goto's as part the MIR, maybe replacing the current higher-level ones.</p>

<h1 id="concepts">Concepts</h1><p>An <em>operator</em> (operation?) is something that takes zero or more <em>values</em> (operands) and produces an another value. An initial value is provided via what is referred to as an <em>input</em>. This is either: the name of a location, the name of a constant, or a nullary operation (one that has no operands). A value always has to be consumed by something. Note that &quot;consume&quot; here only means &quot;used by something&quot; and is not related to the higher-level concept of resource ownership in any way.</p>
<p>An <em>operation sequence</em> starts with an input, is followed by zero or more operators, and ends in an output.</p>
<p>An <em>output</em> is a special operator that accepts one or more operands but doesn't produce a value.</p>

<h2 id="effects">Effects</h2><p>There are three kinds of <em>effects</em>: control-flow effects, location effects, and general effects. Applying an operator can have one or more of these effects.</p>
<p>Location effects are encoded via a special parameterized operator: the <tt class="docutils literal"><span class="pre">tag</span></tt> operator. It takes a single <em>lvalue</em> as input and is purely declarative. Applying the operator that the tagged lvalue is an operand to then has the provided effect to the on the lvalue's underlying location.</p>

<h1 id="structure">Structure</h1><p>Everything part of the MIR is stored in a <tt class="docutils literal"><span class="pre">MirTree</span></tt> (which is a single <tt class="docutils literal"><span class="pre">seq</span></tt> of <tt class="docutils literal"><span class="pre">MirNode</span></tt>s). This simplifies processing and applying changes, as all information is encoded with <tt class="docutils literal"><span class="pre">MirNode</span></tt>s. There are downside to this, however (which?).</p>

<h2 id="highminuslevel">High-level</h2><p>On an abstract level, a tree/sequence-hybrid representation is used. That is, some constructs (mostly statements) use a node-tree tructure while others use a node <em>sequence</em>. Both are stored in the same underlying storage buffer -- they're not separated.</p>
<p>Due to the focus on control-flow, the nodes are ordered in such as way as that a linear iteration over all nodes will yield them in an order that reflects how the operators the nodes represent are executed in the final program (ignoring loops and branching control-flow). This was an explicit design goal.</p>

<h2 id="memory-layout">Memory layout</h2><p>Nodes are layed out as a flat contiguous sequence in memory. This allows for efficient linear traversal and random access, which is not possible with a pointer-based tree structure (such as the one currently used with the AST).</p>

<h1 id="grammar">Grammar</h1><p>The MIR grammar, represented in EBNF. It describes how the nodes are layed out in memory:</p>
<pre class="listing">obj-constr = &quot;objConstr&quot;, {&quot;field&quot;}, &quot;end&quot;

name = &quot;proc&quot; | &quot;const&quot; | &quot;global&quot; | &quot;param&quot; | &quot;local&quot; | &quot;temp&quot; | &quot;type&quot; |
       &quot;literal&quot;

def = &quot;def&quot;, name, &quot;end&quot; {* note: not all names are semantically valid inside a 'def' *}

stmt-list  = &quot;stmtList&quot;, {stmt-list-item}, &quot;end&quot;
stmt = stmt-list | single-stmt
if-stmt    = &quot;if&quot;, stmt, &quot;end&quot;
while-stmt = &quot;while&quot;, stmt, &quot;end&quot;
block-stmt = &quot;block&quot;, stmt, &quot;end&quot;

branch-val = &quot;literal&quot; | &quot;type&quot;
branch = &quot;branch&quot;, {branch-val}, stmt, &quot;end&quot;

case-stmt = &quot;case&quot;, branch, {branch}, &quot;end&quot;

except-branch = &quot;branch&quot;, {(&quot;type&quot; | &quot;pnode&quot;)}, stmt, &quot;end&quot;

except   = &quot;except&quot;, except-branch, {except-branch}, &quot;end&quot;
finally  = &quot;finally&quot;, stmt, &quot;end&quot;
try-stmt = &quot;try&quot;, stmt, [except], [finally], &quot;end&quot;

scope = &quot;scope&quot;, {stmt-list-item}, &quot;end&quot;

single-stmt = &quot;break&quot; | &quot;return&quot; | &quot;pnode&quot; | def | while-stmt | try-stmt |
              block-stmt | scope

region = &quot;region&quot;, {stmt-list-item}, &quot;end&quot;

arg = in-op, {in-out-op}, (&quot;arg&quot; | &quot;name&quot; | &quot;consume&quot;)
arg-block-item = arg | stmt-list-item
arg-block = &quot;argBlock&quot;, {arg-block-item}, arg, &quot;end&quot;

in-op     = &quot;none&quot; | name | arg-block | &quot;opParam&quot; {* may only appear inside a region *}
out-op    = &quot;void&quot; | &quot;raise&quot; | &quot;init&quot; | &quot;fastAsgn&quot; | &quot;asgn&quot; | &quot;switch&quot; |
            &quot;asm&quot; | &quot;emit&quot; | def | if-stmt | case-stmt | region
in-out-op = &quot;magic&quot; | &quot;call&quot; | &quot;pathNamed&quot; | &quot;pathPos&quot; | &quot;pathArray&quot; |
            &quot;pathVariant&quot; | &quot;pathConv&quot; | &quot;constr&quot; | obj-constr | &quot;cast&quot; |
            &quot;deref&quot; | &quot;addr&quot; | &quot;stdConv&quot; | &quot;conv&quot; | &quot;view&quot; | &quot;derefView&quot;

sequence = in-op, {in-out-op}, out-op

stmt-list-item = sequence | single-stmt

top-level = stmt-list-item {* the entry point *}</pre>


    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2023-10-07 00:00:00 UTC</small>
      </div>
    </div>
  </div>
</div>
</body>
</html>
