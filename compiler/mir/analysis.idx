Values	mir/analysis.html#Values	analysis: Values	
skipConversions	mir/analysis.html#skipConversions,MirTree,OpValue	analysis: skipConversions(tree: MirTree; val: OpValue): OpValue	
isOwned	mir/analysis.html#isOwned,Values,OpValue	analysis: isOwned(v: Values; val: OpValue): bool	
markOwned	mir/analysis.html#markOwned,Values,OpValue	analysis: markOwned(v: var Values; val: OpValue)	
isAlive	mir/analysis.html#isAlive,MirTree,DataFlowGraph,Values,Subgraph,Path,InstrPos	analysis: isAlive(tree: MirTree; cfg: DataFlowGraph; v: Values; span: Subgraph; loc: Path;\n        start: InstrPos): bool	
isLastRead	mir/analysis.html#isLastRead,MirTree,DataFlowGraph,Subgraph,Path,InstrPos	analysis: isLastRead(tree: MirTree; cfg: DataFlowGraph; span: Subgraph; loc: Path;\n           start: InstrPos): bool	
isLastWrite	mir/analysis.html#isLastWrite,MirTree,DataFlowGraph,Subgraph,Path,InstrPos	analysis: isLastWrite(tree: MirTree; cfg: DataFlowGraph; span: Subgraph; loc: Path;\n            start: InstrPos): tuple[result, exits, escapes: bool]	
computeAliveOp	mir/analysis.html#computeAliveOp,MirTree,Values,T,Opcode,OpValue	analysis: computeAliveOp[T: PSym | TempId](tree: MirTree; values: Values; loc: T;\n                                 op: Opcode; n: OpValue): AliveState	
computeAlive	mir/analysis.html#computeAlive,MirTree,DataFlowGraph,Values,Subgraph,T,staticComputeAliveProc[T]	analysis: computeAlive[T](tree: MirTree; cfg: DataFlowGraph; values: Values;\n                span: Subgraph; loc: T; op: static ComputeAliveProc[T]): tuple[\n    alive, escapes: bool]	
doesGlobalEscape	mir/analysis.html#doesGlobalEscape,MirTree,Subgraph,InstrPos,PSym	analysis: doesGlobalEscape(tree: MirTree; scope: Subgraph; start: InstrPos; s: PSym): bool	
