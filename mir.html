<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Mid-end intermediate representation</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Mid-end intermediate representation</h1>
    <div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
This document is a work in progress.</div>

<h1 id="overview">Overview</h1><p>The MIR is a desugared, simplified, and flattened intermediate representation (=IR) of NimSkull code that is intended for analysis, transformations, and lowerings.</p>
<p>In the compilation pipeline, the stage using the MIR is located after semantic analysis and high-level transformation (<tt class="docutils literal"><span class="pre">transf</span></tt>) but before code generation.</p>
<div class="admonition admonition-info"><span class="admonition-info-text"><b>Note:</b></span>
The plan is to replace the current IR consumed by the code generators (i.e., the <tt class="docutils literal"><span class="pre">CgNode</span></tt> IR) with the MIR</div>

<h1 id="semantics">Semantics</h1><pre class="listing">NAME = &lt;Temp&gt;   # a temporary introduced during the MIR phase
     | &lt;Alias&gt;  # a temporary view introduced during the MIR phase
     | &lt;Local&gt;  # a user-defined local or temporary introduce prior to the
                # MIR phase
     | &lt;Global&gt; # a user-defined global
     | &lt;Const&gt;  # a user-defined constant

LVALUE = NAME
       | PathNamed   LVALUE &lt;Field&gt;    # named field access (objects only)
       | PathPos     LVALUE &lt;Position&gt; # positional field access (tuples only)
       | PathVariant LVALUE &lt;Field&gt;    # access a variant within an object
       | PathConv    LVALUE &lt;Type&gt;     # access a sub- or super-type of
       | PathArray   LVALUE (NAME | &lt;Literal&gt;) # access an array at given
                                       # position
       | Deref       NAME              # dereference a `ptr` or `ref`
       | DerefView   NAME              # dereference a `var` or `lent`

VALUE = &lt;Literal&gt;
      | &lt;Proc&gt;
      | &lt;Type&gt;
      | LVALUE

CALL_ARG = Arg VALUE                    # pass-by-value argument
         | Arg &lt;none&gt;                   # argument that's going to be omitted
                                        # later
         | Name LVALUE                  # pass-by-name argument where the
                                        # lvalue is only used for reading
         | Name (Tag &lt;Effect&gt; LVALUE)   # pass-by-name argument where the
                                        # lvalue is used for mutation
         | Consume VALUE                # pass-by-value argument, but
                                        # the value is consumed (i.e., moved)

CONSTR_ARG = Arg VALUE
           | Consume OPERAND

CALL_EXPR = Call &lt;Proc&gt; CALL_ARG ...   # a static call of the provided
                                       # procedure with the given arguments
          | Call LVALUE CALL_ARG ...   # indirect call
          | Call &lt;Magic&gt; CALL_ARG ...  # a call of a magic procedure (i.e.,
                                       # a procedure that is either going to
                                       # be lowered into something else, or
                                       # one for which the behaviour cannot
                                       # be represented in the MIR)

RVALUE = CALL_EXPR
       | Constr   CONSTR_ARG ...       # construct a tuple, closure, set, or
       | ObjConstr (&lt;Field&gt; CONSTR_ARG) ... # construct an `object` or
                                       # `ref object`
                                       # array
       | StdConv  VALUE                # number conversion or conversion
                                       # between cstring and string
       | Conv     VALUE                # same as `StdConv`. Only duplicate
                                       # for legacy code generator reasons
       | Cast     VALUE                # reinterpret the value as a different
                                       # type
       | Addr     LVALUE               # create a pointer from the lvalue
       | View     LVALUE               # create a view (`var`/`lent`) of the
                                       # lvalue
       | ToSlice  VALUE                # create an `openArray` slice of
                                       # the full sequence

FULL_VALUE = RVALUE | VALUE

STATEMENT =
          | StmtList STATEMENT ...    # a list of statements
          | Scope STATEMENT           # wrap the statement in a scope, which
                                      # delimits the lifetime of all
                                      # definitions within
          | Def NAME none             # definition
          | Def NAME FULL_VALUE       # definition + initial value assignment
          | DefCursor NAME            # definition of non-owning location
          | DefCursor NAME FULL_VALUE # same as above, but with initial
                                      # assignment
          | Bind &lt;Alias&gt; LVALUE       # bind the lvalue to the given alias
          | BindMut &lt;Alias&gt; LVALUE    # bind the lvalue to the given alias.
                                      # The alias may be used for mutations
                                      # (e.g., on the left of assignments)
          | Void LVALUE               # evaluates the lvalue for side-effects
                                      # and acts as a usage of the lvalue
                                      # during data-flow analysis
          | Void CALL_EXPR            # represents a void call. The called
                                      # procedure or magic *must* have a
                                      # `void`` return type
          | Asgn LVALUE FULL_VALUE    # normal assignment of the right value
                                      # to the left location
          | Init LVALUE FULL_VALUE    # initial assignment (the destination
                                      # is empty)
          | FastAsgn LVALUE FULL_VALUE# fast assignment (cannot be rewritten
                                      # into a full copy)
          | Switch LVALUE FULL_VALUE  # changes the active branch of a
                                      # variant. Unclear semantics.
          | If VALUE STATEMENT        # if the value evaluates to true
                                      # execute the statement
          | Case VALUE BRANCH_LIST    # dispatch to one of the branches based
                                      # on the value, where value must be
                                      # either of integer, float, or string
                                      # type
          | Block &lt;Label&gt; STATEMENT   # run the wrapped statement and provide
                                      # a named exit. The label must be
                                      # unique across all blocks in the
                                      # procedure
          | Break &lt;Label&gt;             # exit the enclosing block that has the
                                      # given label
          | Repeat STATEMENT          # unconditional loop. Repeat the
                                      # statement for an indefinite amount
                                      # of times
          | TRY_STMT
          | Raise LVALUE              # push the given exception to the
                                      # exception stack and start exceptional
                                      # control-flow. The `ref object` is
                                      # consumed
          | Raise &lt;None&gt;              # re-raise the current exception
          | Return                    # exit the procedure, but execute all
                                      # enclosing finalizers first (from
                                      # innermost to outermost)
          | Emit VALUE ...
          | Asm VALUE ...

BRANCH_LIST = (Branch &lt;Literal&gt; ... STATEMENT) ... # a list of branches
HANDLER = Except (Branch &lt;Type&gt; ... STATEMENT) ... # exception handler

TRY_STMT = Try STATEMENT (HANDLER)? (Finally STATEMENT)?
  # if a handler is present, all `raise` statements within the tried
  # statement are redirected to the handler. If a finalizer is present, all
  # control-flow exiting the tried statement or handler is first redirected
  # to the finalizer.</pre><p>Only allowing calls, conversions, casts, etc. as the source operand (i.e., on the right) of an assignment makes sure that they always have named receivers, which:</p>
<ul class="simple"><li>ensures an atomic statement (e.g., assignment) only has at most one control- flow effect, making control-/data-flow analysis easier</li>
<li>allows for local, assignment-based lowering of call, magics, etc.</li>
</ul>
<p>If a call raises an exception, whether the assignment destination is written to is currently undefined.</p>

<h2 id="types">Types</h2><p><tt class="docutils literal"><span class="pre">PType</span></tt> is currently re-used for representing types at the MIR stage. In the future, the usage of <tt class="docutils literal"><span class="pre">PType</span></tt> will be replaced with simplified and more data- oriented version that betters supports lowering and traversal.</p>

<h2 id="effects">Effects</h2><p>Lvalues passed to by-name parameters may optionally be tagged with an <em>effect</em>. The effect describes what may happen to the underlying location <em>during</em> execution of the procedure. If no effects are specified, the location may only be read from during execution of the procedure.</p>
<p>This information is intended for use by data-flow analysis and code generators.</p>

<h1 id="storage">Storage</h1><p>The MIR uses a tree-based representation similar to the AST. For easier processing and faster access, the whole code for a procedure is stored in a single sequence of <em>nodes</em>, with the nodes forming a tree.</p>
<p>Sub-trees are currently delimited via an explicit <tt class="docutils literal"><span class="pre">End</span></tt> node.</p>



    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2023-12-27 00:00:00 UTC</small>
      </div>
    </div>
  </div>
</div>
</body>
</html>
