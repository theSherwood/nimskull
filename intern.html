<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>doc/intern</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">doc/intern</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple-boot">
      <li><a href="manual.html">Manual</a></li>
      <li><a href="style_guide.html">Style guide</a></li>
      <li><a href="contributing.html">Contribution guide</a></li>
      <li><a href="lib.html">Standard library</a></li>
      <li><a href="theindex.html">Index</a></li>
      <li><a href="compiler/theindex.html">Compiler docs</a></li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
    <div class="search-groupby">
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>

  <ul class="simple simple-toc" id="toc-list">
<ul class="simple"><li><a class="reference" id="glossary_toc" href="#glossary">Glossary</a></li>
<ul class="simple"><li><a class="reference" id="glossary-languageminusrelated-terms_toc" href="#glossary-languageminusrelated-terms">Language-related terms</a></li>
<li><a class="reference" id="glossary-compiler-internal-terms_toc" href="#glossary-compiler-internal-terms">Compiler internal terms</a></li>
</ul><li><a class="reference" id="directory-structure_toc" href="#directory-structure">Directory structure</a></li>
<li><a class="reference" id="bootstrapping-the-compiler_toc" href="#bootstrapping-the-compiler">Bootstrapping the compiler</a></li>
<li><a class="reference" id="developing-the-compiler_toc" href="#developing-the-compiler">Developing the compiler</a></li>
<li><a class="reference" id="the-compiler-s-architecture_toc" href="#the-compiler-s-architecture">The compiler's architecture</a></li>
<ul class="simple"><li><a class="reference" id="the-compiler-s-architecture-short-description-of-nim-s-modules_toc" href="#the-compiler-s-architecture-short-description-of-nim-s-modules">Short description of Nim's modules</a></li>
<li><a class="reference" id="the-compiler-s-architecture-the-syntax-tree_toc" href="#the-compiler-s-architecture-the-syntax-tree">The syntax tree</a></li>
<li><a class="reference" id="the-compiler-s-architecture-errors-nkerror_toc" href="#the-compiler-s-architecture-errors-nkerror">Errors (nkError)</a></li>
<li><a class="reference" id="the-compiler-s-architecture-reports_toc" href="#the-compiler-s-architecture-reports">Reports</a></li>
<li><a class="reference" id="the-compiler-s-architecture-vm_toc" href="#the-compiler-s-architecture-vm">VM</a></li>
</ul><li><a class="reference" id="bisecting-for-regressions_toc" href="#bisecting-for-regressions">Bisecting for regressions</a></li>
<li><a class="reference" id="runtimes_toc" href="#runtimes">Runtimes</a></li>
<li><a class="reference" id="coding-guidelines_toc" href="#coding-guidelines">Coding Guidelines</a></li>
<li><a class="reference" id="porting-to-new-platforms_toc" href="#porting-to-new-platforms">Porting to new platforms</a></li>
<li><a class="reference" id="runtime-type-information_toc" href="#runtime-type-information">Runtime type information</a></li>
<li><a class="reference" id="magics-and-compilerprocs_toc" href="#magics-and-compilerprocs">Magics and compilerProcs</a></li>
<li><a class="reference" id="code-generation-for-closures_toc" href="#code-generation-for-closures">Code generation for closures</a></li>
<ul class="simple"><li><a class="reference" id="code-generation-for-closures-design_toc" href="#code-generation-for-closures-design">Design</a></li>
<li><a class="reference" id="code-generation-for-closures-accumulator_toc" href="#code-generation-for-closures-accumulator">Accumulator</a></li>
<li><a class="reference" id="code-generation-for-closures-internals_toc" href="#code-generation-for-closures-internals">Internals</a></li>
</ul><li><a class="reference" id="notes-on-type-and-ast-representation_toc" href="#notes-on-type-and-ast-representation">Notes on type and AST representation</a></li>
<ul class="simple"><li><a class="reference" id="notes-on-type-and-ast-representation-integer-literals_toc" href="#notes-on-type-and-ast-representation-integer-literals">Integer literals</a></li>
</ul></ul>
</ul>

  </div>
  &nbsp;&nbsp;<a
href="https://github.com/nim-works/nimskull/tree/4096bd0d0e16f9f1a795c24c02ad42b924123a21/doc/intern.rst#L1"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="https://github.com/nim-works/nimskull/edit/devel/doc/intern.rst#L1" class="link-seesrc" target="_blank" >Edit</a>

  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc"><h1 id="internals-of-the-nimskull-compiler"><center>Internals of the NimSkull Compiler</center></h1><blockquote><p>&quot;Abstraction is layering ignorance on top of reality.&quot; -- Richard Gabriel</p></blockquote>

<h2><a class="toc-backref" id="glossary" href="#glossary">Glossary</a></h2><p>Some specific terms and names are used throughout this document and in the wider compiler codebase. In order to reduce confusion and specify internal naming consistency this section tries to provide a comprehensive list of said terms/names.</p>

<h3><a class="toc-backref" id="glossary-languageminusrelated-terms" href="#glossary-languageminusrelated-terms">Language-related terms</a></h3><ul class="simple"><li>instantiation: substitution of the placeholder generic parameters in the procedure or type definition.</li>
</ul>

<h3><a class="toc-backref" id="glossary-compiler-internal-terms" href="#glossary-compiler-internal-terms">Compiler internal terms</a></h3><p>Things that are <em>mostly</em> seen in the compiler codebase internally and not often used in the regular language.</p>
<ul class="simple"><li>formal: expected, &quot;as defined&quot; mostly mentioned in relation to the function processing (<tt class="docutils literal"><span class="pre">sigmatch.nim</span></tt>), used to refer to the</li>
<li>callsite: location of the function call in the code</li>
</ul>

<h2><a class="toc-backref" id="directory-structure" href="#directory-structure">Directory structure</a></h2><p>The  nimskull project's directory structure is:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">bin/</span></tt>, <tt class="docutils literal"><span class="pre">build/</span></tt> - these directories are empty, but are used when  nimskull is built.</li>
<li><tt class="docutils literal"><span class="pre">compiler/</span></tt> - the compiler source code. Also includes nimfix, and plugins within <tt class="docutils literal"><span class="pre">compiler/nimfix</span></tt> and <tt class="docutils literal"><span class="pre">compiler/plugins</span></tt> respectively.</li>
<li><tt class="docutils literal"><span class="pre">nimsuggest</span></tt> - the nimsuggest tool.</li>
<li><tt class="docutils literal"><span class="pre">config/</span></tt> - the configuration for the compiler and documentation generator.</li>
<li><tt class="docutils literal"><span class="pre">dist</span></tt> - additional packages for distribution</li>
<li><tt class="docutils literal"><span class="pre">doc/</span></tt> - the documentation files in reStructuredText format.</li>
<li><dl class="docutils"><dt><tt class="docutils literal"><span class="pre">lib/</span></tt> - the standard library, including:</dt>
<dd><ul class="simple"><li><tt class="docutils literal"><span class="pre">pure/</span></tt> - modules in the standard library written in pure  nimskull.</li>
<li><tt class="docutils literal"><span class="pre">impure/</span></tt> - modules in the standard library written in pure  nimskull with dependencies written in other languages.</li>
<li><tt class="docutils literal"><span class="pre">wrappers/</span></tt> - modules that wrap dependencies written in other languages.</li>
</ul>
</dd>
</dl>
</li>
<li><tt class="docutils literal"><span class="pre">tests/</span></tt> - contains categorized tests for the compiler and standard library.<ul class="simple"><li><tt class="docutils literal"><span class="pre">tests/lang</span></tt> - tests containing language specification</li>
</ul>
</li>
<li><tt class="docutils literal"><span class="pre">tools/</span></tt> - the tools including <tt class="docutils literal"><span class="pre">koch</span></tt>, <tt class="docutils literal"><span class="pre">niminst</span></tt> and <tt class="docutils literal"><span class="pre">nimweb</span></tt> (mostly invoked via <tt class="docutils literal"><span class="pre">koch</span></tt>).</li>
<li><tt class="docutils literal"><span class="pre">tools/koch/koch.nim</span></tt> - the tool used to bootstrap  nimskull, generate C sources, build the website, and generate the documentation.</li>
<li><tt class="docutils literal"><span class="pre">koch.py</span></tt> - the script to bootstrap and launch <tt class="docutils literal"><span class="pre">koch.nim</span></tt>.</li>
</ul>

<h2><a class="toc-backref" id="bootstrapping-the-compiler" href="#bootstrapping-the-compiler">Bootstrapping the compiler</a></h2><p>Compiling the compiler is a simple matter of running:</p>
<pre class="listing"><span class="program">./koch.py</span> <span class="option">boot</span> <span class="option">-d:release</span></pre><p>For a debug version use:</p>
<pre class="listing"><span class="program">./koch.py</span> <span class="option">boot</span></pre><p>And for a debug version compatible with GDB:</p>
<pre class="listing"><span class="program">./koch.py</span> <span class="option">boot</span> <span class="option">--debuginfo</span> <span class="option">--linedir:on</span></pre><p>The <tt class="docutils literal"><span class="pre"><span class="program">koch</span></span></tt> program is  NimSkull's maintenance script. It is a replacement for make and shell scripting with the advantage that it is much more portable. More information about its options can be found in the <a class="reference external" href="koch.html">koch</a> documentation.</p>

<h2><a class="toc-backref" id="developing-the-compiler" href="#developing-the-compiler">Developing the compiler</a></h2><p>To create a new compiler for each run, use <tt class="docutils literal"><span class="pre"><span class="program">koch</span> <span class="option">temp</span></span></tt>:</p>
<pre class="listing"><span class="program">./koch.py</span> <span class="option">temp</span> <span class="option">c</span> <span class="Identifier">test.nim</span></pre><p><tt class="docutils literal"><span class="pre"><span class="program">./koch.py</span> <span class="option">temp</span></span></tt> creates a debug build of the compiler, which is useful to create stacktraces for compiler debugging.</p>
<p>You can of course use GDB or Visual Studio to debug the compiler (via <tt class="docutils literal"><span class="pre option">--debuginfo --lineDir:on</span></tt>). However, there are also lots of procs that aid in debugging:</p>
<pre class="listing"><span class="Comment"># dealing with PNode:</span>
<span class="Identifier">echo</span> <span class="Identifier">renderTree</span><span class="Punctuation">(</span><span class="Identifier">someNode</span><span class="Punctuation">)</span>
<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">someNode</span><span class="Punctuation">)</span> <span class="Comment"># some JSON representation</span>

<span class="Comment"># dealing with PType:</span>
<span class="Identifier">echo</span> <span class="Identifier">typeToString</span><span class="Punctuation">(</span><span class="Identifier">someType</span><span class="Punctuation">)</span>
<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">someType</span><span class="Punctuation">)</span>

<span class="Comment"># dealing with PSym:</span>
<span class="Identifier">echo</span> <span class="Identifier">symbol</span><span class="Operator">.</span><span class="Identifier">name</span><span class="Operator">.</span><span class="Identifier">s</span>
<span class="Identifier">debug</span><span class="Punctuation">(</span><span class="Identifier">symbol</span><span class="Punctuation">)</span>

<span class="Comment"># pretty prints the |NimSkull| ast, but annotates symbol IDs:</span>
<span class="Identifier">echo</span> <span class="Identifier">renderTree</span><span class="Punctuation">(</span><span class="Identifier">someNode</span><span class="Punctuation">,</span> <span class="Punctuation">{</span><span class="Identifier">renderIds</span><span class="Punctuation">}</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">??</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">conf</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">info</span><span class="Punctuation">,</span> <span class="StringLit">&quot;temp.nim&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Comment"># only output when it comes from &quot;temp.nim&quot;</span>
  <span class="Identifier">echo</span> <span class="Identifier">renderTree</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">)</span>
<span class="Keyword">if</span> <span class="Punctuation">`</span><span class="Operator">??</span><span class="Punctuation">`</span><span class="Punctuation">(</span><span class="Identifier">conf</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Operator">.</span><span class="Identifier">info</span><span class="Punctuation">,</span> <span class="StringLit">&quot;temp.nim&quot;</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Comment"># why does it process temp.nim here?</span>
  <span class="Identifier">writeStackTrace</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre><p>These procs may not already be imported by the module you're editing. You can import them directly for debugging:</p>
<pre class="listing"><span class="Keyword">from</span> <span class="Identifier">astalgo</span> <span class="Keyword">import</span> <span class="Identifier">debug</span>
<span class="Keyword">from</span> <span class="Identifier">types</span> <span class="Keyword">import</span> <span class="Identifier">typeToString</span>
<span class="Keyword">from</span> <span class="Identifier">renderer</span> <span class="Keyword">import</span> <span class="Identifier">renderTree</span>
<span class="Keyword">from</span> <span class="Identifier">msgs</span> <span class="Keyword">import</span> <span class="Punctuation">`</span><span class="Operator">??</span><span class="Punctuation">`</span></pre>
<h2><a class="toc-backref" id="the-compiler-s-architecture" href="#the-compiler-s-architecture">The compiler's architecture</a></h2><p> NimSkull's current compiler architecture: A lexer/scanner feeds tokens to a parser. The parser builds a syntax tree that is used by the code generators. This syntax tree is the interface between the parser and the code generator. It is essential to understand most of the compiler's code.</p>
<p>Semantic analysis is separated from parsing.</p>

<h3><a class="toc-backref" id="the-compiler-s-architecture-short-description-of-nim-s-modules" href="#the-compiler-s-architecture-short-description-of-nim-s-modules">Short description of Nim's modules</a></h3><table border="1" class="docutils"><tr><th>Module</th><th>Description</th></tr>
<tr><td>nim</td><td>main module: parses the command line and calls <tt class="docutils literal"><span class="pre">main.MainCommand</span></tt></td></tr>
<tr><td>main</td><td>implements the top-level command dispatching</td></tr>
<tr><td>nimconf</td><td>implements the config file reader</td></tr>
<tr><td>syntaxes</td><td>dispatcher for the different parsers and filters</td></tr>
<tr><td>filter_tmpl</td><td>standard template filter (<tt class="docutils literal"><span class="pre">#? stdtempl</span></tt>)</td></tr>
<tr><td>lexbase</td><td>buffer handling of the lexical analyser</td></tr>
<tr><td>lexer</td><td>lexical analyser</td></tr>
<tr><td>parser</td><td>Nim's parser</td></tr>
<tr><td>renderer</td><td>Nim code renderer (AST back to its textual form)</td></tr>
<tr><td>options</td><td>contains global and local compiler options</td></tr>
<tr><td>ast</td><td>type definitions of the abstract syntax tree (AST) and node constructors</td></tr>
<tr><td>astalgo</td><td>algorithms for containers of AST nodes; converting the AST to YAML; the symbol table</td></tr>
<tr><td>passes</td><td>implement the passes manager for passes over the AST</td></tr>
<tr><td>trees</td><td>some algorithms for nodes; this module is less important</td></tr>
<tr><td>types</td><td>module for traversing type graphs; also contain several helpers for dealing with types</td></tr>
<tr><td></td><td></td></tr>
<tr><td>sigmatch</td><td>contains the matching algorithm that is used for proc calls</td></tr>
<tr><td>semexprs</td><td>contains the semantic checking phase for expressions</td></tr>
<tr><td>semstmts</td><td>contains the semantic checking phase for statements</td></tr>
<tr><td>semtypes</td><td>contains the semantic checking phase for types</td></tr>
<tr><td>seminst</td><td>instantiation of generic procs and types</td></tr>
<tr><td>semfold</td><td>contains code to deal with constant folding</td></tr>
<tr><td>semthreads</td><td>deep program analysis for threads</td></tr>
<tr><td>evals</td><td>contains an AST interpreter for compile time evaluation</td></tr>
<tr><td>pragmas</td><td>semantic checking of pragmas</td></tr>
<tr><td></td><td></td></tr>
<tr><td>idents</td><td>implements a general mapping from identifiers to an internal representation (<tt class="docutils literal"><span class="pre">PIdent</span></tt>) that is used so that a simple id-comparison suffices to establish whether two Nim identifiers are equivalent</td></tr>
<tr><td>ropes</td><td>implements long strings represented as trees for lazy evaluation; used mainly by the code generators</td></tr>
<tr><td></td><td></td></tr>
<tr><td>transf</td><td>transformations on the AST that need to be done before code generation</td></tr>
<tr><td>cgen</td><td>main file of the C code generator</td></tr>
<tr><td>ccgutils</td><td>contains helpers for the C code generator</td></tr>
<tr><td>ccgtypes</td><td>the generator for C types</td></tr>
<tr><td>ccgstmts</td><td>the generator for statements</td></tr>
<tr><td>ccgexprs</td><td>the generator for expressions</td></tr>
<tr><td>extccomp</td><td>this module calls the C compiler and linker; interesting if you want to add support for a new C compiler</td></tr>
</table>
<h3><a class="toc-backref" id="the-compiler-s-architecture-the-syntax-tree" href="#the-compiler-s-architecture-the-syntax-tree">The syntax tree</a></h3><p>The syntax tree consists of nodes which may have an arbitrary number of children. Types and symbols are represented by other nodes, because they may contain cycles. The AST changes its shape after semantic checking. This is needed to make life easier for the code generators. See the &quot;ast&quot; module for the type definitions. The <a class="reference external" href="macros.html">macros</a> module contains many examples how the AST represents each syntactic structure.</p>

<h3><a class="toc-backref" id="the-compiler-s-architecture-errors-nkerror" href="#the-compiler-s-architecture-errors-nkerror">Errors (nkError)</a></h3><p>Errors are now stored within the AST itself via <tt class="docutils literal"><span class="pre">nkError</span></tt> nodes, see the <tt class="docutils literal"><span class="pre">compiler/errorhandling</span></tt> module for more details. At the time of writing this is an ongoing <tt class="docutils literal"><span class="pre">refactoring project &lt;https://github.com/nim-works/nimskull/projects/1&gt;</span></tt> _.</p>
<p>The legacy way of error reporting and handling is done via a set of <tt class="docutils literal"><span class="pre">template</span></tt>s and <tt class="docutils literal"><span class="pre">proc</span></tt>s within the <tt class="docutils literal"><span class="pre">msgs</span></tt> module. This complects control flow, as by default it aborts compilation on error and reporting itself. Additionally, it lead to complexity at the time of reporting as a significant amount of contextual information is required, in what is typically a local part of the AST being examined. Please help refactor accordingly if you encounter the legacy method.</p>

<h3><a class="toc-backref" id="the-compiler-s-architecture-reports" href="#the-compiler-s-architecture-reports">Reports</a></h3><p>..note:: Reports are legacy and will be entirely removed/reworked</p>
<p>All output generated during compiler runtime is handled using <tt class="docutils literal"><span class="pre">Report</span></tt> type, defined in <tt class="docutils literal"><span class="pre">reports.nim</span></tt> module. Every single compilation warning, hint, error, and lots of other reports are wrapped into several categories (lexer, parser, sem, internal, external, debug and backend) and passed around.</p>
<p>Each error node (<tt class="docutils literal"><span class="pre">nkError</span></tt>) stores associated report id that is written out during error traversal. Postponed reports are stored in the <tt class="docutils literal"><span class="pre">MsgConfig.reports</span></tt> field, which can be asscessed from <tt class="docutils literal"><span class="pre">ConfigRef.m</span></tt>.</p>
<p>For more details on the specific report kinds and categories see the <tt class="docutils literal"><span class="pre">report.nim</span></tt> module (for type definitions), <tt class="docutils literal"><span class="pre">options.nim</span></tt> (for writing storing postponed or writing out activated reports) and <tt class="docutils literal"><span class="pre">msgs.nim</span></tt> (for main logic related to error handing and report submission).</p>
<p>When report need to be written out it is handed to <tt class="docutils literal"><span class="pre">ConfigRef.structuredReportHook</span></tt> - it can be reimplemented by other tooling, can generate output information in any format (json, pretty-printed, S-expression), and filter it out unnecessary reports. Default implementation of the report hook is provided in the <tt class="docutils literal"><span class="pre">cli_reporter.nim</span></tt> - if you want to improve particular error messages it is (ideally) the only (compiler) file that you need to edit.</p>

<h3><a class="toc-backref" id="the-compiler-s-architecture-vm" href="#the-compiler-s-architecture-vm">VM</a></h3><p>For compile-time code execution nim compiler implements register-based VM with custom instruction set. <tt class="docutils literal"><span class="pre">vmgen.nim</span></tt> implements code generation for the virtual machine, <tt class="docutils literal"><span class="pre">vm.nim</span></tt> provides main execution engine.</p>
<p>Errors generated in the VM are handled using common pipeline - report with necessary location information is generated.</p>

<h2><a class="toc-backref" id="bisecting-for-regressions" href="#bisecting-for-regressions">Bisecting for regressions</a></h2><p><tt class="docutils literal"><span class="pre"><span class="program">./koch.py</span> <span class="option">temp</span></span></tt> returns 125 as the exit code in case the compiler compilation fails. This exit code tells <tt class="docutils literal"><span class="pre"><span class="program">git</span> <span class="option">bisect</span></span></tt> to skip the current commit:</p>
<pre class="listing"><span class="program">git</span> <span class="option">bisect</span> <span class="option">start</span> <span class="option">bad-commit</span> <span class="option">good-commit</span>
<span class="program">git</span> <span class="option">bisect</span> <span class="option">run</span> <span class="Identifier">./koch.py</span> <span class="option">temp</span> <span class="option">-r</span> <span class="option">c</span> <span class="Identifier">test-source.nim</span></pre><p>You can also bisect using custom options to build the compiler, for example if you don't need a debug version of the compiler (which runs slower), you can replace <tt class="docutils literal"><span class="pre"><span class="program">./koch.py</span> <span class="option">temp</span></span></tt> by explicit compilation command, see <a class="reference internal" href="#bootstrapping-the-compiler">Bootstrapping the compiler</a>.</p>

<h2><a class="toc-backref" id="runtimes" href="#runtimes">Runtimes</a></h2><p> NimSkull had two different runtimes at one point, but support for the old one was removed from the compiler. Some documentation might still use the terms &quot;old runtime&quot; and &quot;new runtime&quot;.</p>
<p>In order to continue bootstrapping, the code for the implementation of the &quot;old runtime&quot; still exists. The new runtime is active <tt class="docutils literal"><span class="pre">when defined(nimV2)</span></tt>.</p>

<h2><a class="toc-backref" id="coding-guidelines" href="#coding-guidelines">Coding Guidelines</a></h2><ul class="simple"><li>We follow  NimSkull's official style guide, see <a class="reference external" href="nep1.html">nep1.html</a>.</li>
<li>Max line length is 100 characters.</li>
<li>Provide spaces around binary operators if that enhances readability.</li>
<li>Use a space after a colon, but not before it.</li>
</ul>
<p>See also the <a class="reference external" href="apis.html">API naming design</a> document.</p>

<h2><a class="toc-backref" id="porting-to-new-platforms" href="#porting-to-new-platforms">Porting to new platforms</a></h2><p>Porting  NimSkull to a new architecture is pretty easy, since C is the most portable programming language (within certain limits) and  NimSkull generates C code, porting the code generator is not necessary.</p>
<p>POSIX-compliant systems on conventional hardware are usually pretty easy to port: Add the platform to <tt class="docutils literal"><span class="pre">platform</span></tt> (if it is not already listed there), check that the OS, System modules work and recompile  NimSkull.</p>

<h2><a class="toc-backref" id="runtime-type-information" href="#runtime-type-information">Runtime type information</a></h2><p><strong>Note</strong>: This section describes the &quot;old runtime&quot;.</p>
<p><em>Runtime type information</em> (RTTI) is needed for several aspects of the  NimSkull programming language:</p>
<dl class="docutils"><dt>Deep copying</dt>
<dd>Compared to a normal copy, a <em>deep</em> copy also creates copies of cells referenced by <tt class="docutils literal"><span class="pre">ref</span></tt>s, instead of just copying the pointers. The type of the <tt class="docutils literal"><span class="pre">ref</span></tt> can be different from the type of the cell, so an approach only taking static types into account wouldn't work.</dd>
</dl>
<p>We already know the type information as a graph in the compiler. Thus we need to serialize this graph as RTTI for C code generation. Look at the file <tt class="docutils literal"><span class="pre">lib/system/hti.nim</span></tt> for more information.</p>

<h2><a class="toc-backref" id="magics-and-compilerprocs" href="#magics-and-compilerprocs">Magics and compilerProcs</a></h2><p>The <tt class="docutils literal"><span class="pre">system</span></tt> module contains the part of the RTL which needs support by compiler magic. The C code generator generates the C code for it, just like any other module. However, calls to some procedures like <tt class="docutils literal"><span class="pre">addInt</span></tt> are inserted by the generator. Therefore there is a table (<tt class="docutils literal"><span class="pre">compilerprocs</span></tt>) with all symbols that are marked as <tt class="docutils literal"><span class="pre">compilerproc</span></tt>. <tt class="docutils literal"><span class="pre">compilerprocs</span></tt> are needed by the code generator. A <tt class="docutils literal"><span class="pre">magic</span></tt> proc is not the same as a <tt class="docutils literal"><span class="pre">compilerproc</span></tt>: A <tt class="docutils literal"><span class="pre">magic</span></tt> is a proc that needs compiler magic for its semantic checking, a <tt class="docutils literal"><span class="pre">compilerproc</span></tt> is a proc that is used by the code generator.</p>

<h2><a class="toc-backref" id="code-generation-for-closures" href="#code-generation-for-closures">Code generation for closures</a></h2><p>Code generation for closures is implemented by <span id="lambda-lifting_1">lambda lifting</span>.</p>

<h3><a class="toc-backref" id="code-generation-for-closures-design" href="#code-generation-for-closures-design">Design</a></h3><p>A <tt class="docutils literal"><span class="pre">closure</span></tt> proc var can call ordinary procs of the default  NimSkull calling convention. But not the other way round! A closure is implemented as a <tt class="docutils literal"><span class="pre">tuple[prc, env]</span></tt>. <tt class="docutils literal"><span class="pre">env</span></tt> can be nil implying a call without a closure. This means that a call through a closure generates an <tt class="docutils literal"><span class="pre">if</span></tt> but the interoperability is worth the cost of the <tt class="docutils literal"><span class="pre">if</span></tt>. Thunk generation would be possible too, but it's slightly more effort to implement.</p>
<p>Tests with GCC on Amd64 showed that it's really beneficial if the 'environment' pointer is passed as the last argument, not as the first argument.</p>
<p>Proper thunk generation is harder because the proc that is to wrap could stem from a complex expression:</p>
<pre class="listing"><span class="Identifier">receivesClosure</span><span class="Punctuation">(</span><span class="Identifier">returnsDefaultCC</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">)</span></pre><p>A thunk would need to call 'returnsDefaultCC[i]' somehow and that would require an <em>additional</em> closure generation... Ok, not really, but it requires to pass the function to call. So we'd end up with 2 indirect calls instead of one. Another much more severe problem which this solution is that it's not GC-safe to pass a proc pointer around via a generic <tt class="docutils literal"><span class="pre">ref</span></tt> type.</p>
<p>Example code:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span>

<span class="Keyword">var</span> <span class="Identifier">add2</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">add2</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment">#OUT 7</span></pre><p>This should produce roughly this code:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Env</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># data</span>

<span class="Keyword">proc</span> <span class="Identifier">anon</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">Env</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">x</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">env</span><span class="Punctuation">:</span> <span class="Identifier">Env</span>
  <span class="Identifier">new</span> <span class="Identifier">env</span>
  <span class="Identifier">env</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">anon</span><span class="Punctuation">,</span> <span class="Identifier">env</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">add2</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Keyword">let</span> <span class="Identifier">tmp</span> <span class="Operator">=</span> <span class="Keyword">if</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">data</span> <span class="Operator">==</span> <span class="Keyword">nil</span><span class="Punctuation">:</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">prc</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Keyword">else</span><span class="Punctuation">:</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">prc</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">,</span> <span class="Identifier">add2</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">tmp</span></pre><p>Beware of nesting:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">lambda</span> <span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
    <span class="Keyword">return</span> <span class="Identifier">lambda</span> <span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
      <span class="Keyword">return</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span> <span class="Operator">+</span> <span class="Identifier">z</span>

<span class="Keyword">var</span> <span class="Identifier">add24</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">add24</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span> <span class="Comment">#OUT 11</span></pre><p>This should produce roughly this code:</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">EnvX</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Comment"># data</span>
  
  <span class="Identifier">EnvY</span> <span class="Operator">=</span> <span class="Keyword">ref</span> <span class="Keyword">object</span>
    <span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span>
    <span class="Identifier">ex</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span>

<span class="Keyword">proc</span> <span class="Identifier">lambdaZ</span><span class="Punctuation">(</span><span class="Identifier">z</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">ey</span><span class="Punctuation">:</span> <span class="Identifier">EnvY</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
  <span class="Keyword">return</span> <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">ex</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">+</span> <span class="Identifier">z</span>

<span class="Keyword">proc</span> <span class="Identifier">lambdaY</span><span class="Punctuation">(</span><span class="Identifier">y</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">ex</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">EnvY</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ey</span><span class="Punctuation">:</span> <span class="Identifier">EnvY</span>
  <span class="Identifier">new</span> <span class="Identifier">ey</span>
  <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">y</span> <span class="Operator">=</span> <span class="Identifier">y</span>
  <span class="Identifier">ey</span><span class="Operator">.</span><span class="Identifier">ex</span> <span class="Operator">=</span> <span class="Identifier">ex</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">lambdaZ</span><span class="Punctuation">,</span> <span class="Identifier">ey</span><span class="Punctuation">)</span>

<span class="Keyword">proc</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="Identifier">x</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">tuple</span><span class="Punctuation">[</span><span class="Identifier">prc</span><span class="Punctuation">,</span> <span class="Identifier">data</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span><span class="Punctuation">]</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">ex</span><span class="Punctuation">:</span> <span class="Identifier">EnvX</span>
  <span class="Identifier">ex</span><span class="Operator">.</span><span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span>
  <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Punctuation">(</span><span class="Identifier">labmdaY</span><span class="Punctuation">,</span> <span class="Identifier">ex</span><span class="Punctuation">)</span>

<span class="Keyword">var</span> <span class="Identifier">tmp</span> <span class="Operator">=</span> <span class="Identifier">add</span><span class="Punctuation">(</span><span class="DecNumber">2</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">tmp2</span> <span class="Operator">=</span> <span class="Identifier">tmp</span><span class="Operator">.</span><span class="Identifier">fn</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">tmp</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
<span class="Keyword">var</span> <span class="Identifier">add24</span> <span class="Operator">=</span> <span class="Identifier">tmp2</span><span class="Operator">.</span><span class="Identifier">fn</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">,</span> <span class="Identifier">tmp2</span><span class="Operator">.</span><span class="Identifier">data</span><span class="Punctuation">)</span>
<span class="Identifier">echo</span> <span class="Identifier">add24</span><span class="Punctuation">(</span><span class="DecNumber">5</span><span class="Punctuation">)</span></pre><p>We could get rid of nesting environments by always inlining inner anon procs. More useful is escape analysis and stack allocation of the environment, however.</p>

<h3><a class="toc-backref" id="code-generation-for-closures-accumulator" href="#code-generation-for-closures-accumulator">Accumulator</a></h3><pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">getAccumulator</span><span class="Punctuation">(</span><span class="Identifier">start</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">closure</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">i</span> <span class="Operator">=</span> <span class="Identifier">start</span>
  <span class="Keyword">return</span> <span class="Identifier">lambda</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Identifier">inc</span> <span class="Identifier">i</span>
    <span class="Keyword">return</span> <span class="Identifier">i</span>

<span class="Keyword">proc</span> <span class="Identifier">p</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">delta</span> <span class="Operator">=</span> <span class="DecNumber">7</span>
  <span class="Keyword">proc</span> <span class="Identifier">accumulator</span><span class="Punctuation">(</span><span class="Identifier">start</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Keyword">proc</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
    <span class="Keyword">var</span> <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">start</span><span class="Operator">-</span><span class="DecNumber">1</span>
    <span class="Identifier">result</span> <span class="Operator">=</span> <span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">int</span> <span class="Operator">=</span>
      <span class="Identifier">x</span> <span class="Operator">=</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">delta</span>
      <span class="Identifier">inc</span> <span class="Identifier">delta</span>
      <span class="Keyword">return</span> <span class="Identifier">x</span>
  
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">accumulator</span><span class="Punctuation">(</span><span class="DecNumber">3</span><span class="Punctuation">)</span>
  <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="Identifier">accumulator</span><span class="Punctuation">(</span><span class="DecNumber">4</span><span class="Punctuation">)</span>
  <span class="Identifier">echo</span> <span class="Identifier">a</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">+</span> <span class="Identifier">b</span><span class="Punctuation">(</span><span class="Punctuation">)</span></pre>
<h3><a class="toc-backref" id="code-generation-for-closures-internals" href="#code-generation-for-closures-internals">Internals</a></h3><p>Lambda lifting is implemented as part of the <tt class="docutils literal"><span class="pre">transf</span></tt> pass. The <tt class="docutils literal"><span class="pre">transf</span></tt> pass generates code to setup the environment and to pass it around. However, this pass does not change the types! So we have some kind of mismatch here; on the one hand the proc expression becomes an explicit tuple, on the other hand the tyProc(ccClosure) type is not changed. For C code generation it's also important the hidden formal param is <tt class="docutils literal"><span class="pre"><span class="Keyword">void</span><span class="Operator">*</span></span></tt> and not something more specialized. However the more specialized env type needs to passed to the backend somehow. We deal with this by modifying <tt class="docutils literal"><span class="pre">s.ast[paramPos]</span></tt> to contain the formal hidden parameter, but not <tt class="docutils literal"><span class="pre">s.typ</span></tt>!</p>

<h2><a class="toc-backref" id="notes-on-type-and-ast-representation" href="#notes-on-type-and-ast-representation">Notes on type and AST representation</a></h2><p>To be expanded.</p>

<h3><a class="toc-backref" id="notes-on-type-and-ast-representation-integer-literals" href="#notes-on-type-and-ast-representation-integer-literals">Integer literals</a></h3><p>In  NimSkull, there is a redundant way to specify the type of an integer literal. First of all, it should be unsurprising that every node has a node kind. The node of an integer literal can be any of the following values:<pre>nkIntLit, nkInt8Lit, nkInt16Lit, nkInt32Lit, nkInt64Lit,
nkUIntLit, nkUInt8Lit, nkUInt16Lit, nkUInt32Lit, nkUInt64Lit</pre>
</p>
<p>On top of that, there is also the <tt class="docutils literal"><span class="pre">typ</span></tt> field for the type. It the kind of the <tt class="docutils literal"><span class="pre">typ</span></tt> field can be one of the following ones, and it should be matching the literal kind:<pre>tyInt, tyInt8, tyInt16, tyInt32, tyInt64, tyUInt, tyUInt8,
tyUInt16, tyUInt32, tyUInt64</pre>
</p>
<p>Then there is also the integer literal type. This is a specific type that is implicitly convertible into the requested type if the requested type can hold the value. For this to work, the type needs to know the concrete value of the literal. For example an expression <tt class="docutils literal"><span class="pre">321</span></tt> will be of type <tt class="docutils literal"><span class="pre">int literal(321)</span></tt>. This type is implicitly convertible to all integer types and ranges that contain the value <tt class="docutils literal"><span class="pre">321</span></tt>. That would be all builtin integer types except <tt class="docutils literal"><span class="pre">uint8</span></tt> and <tt class="docutils literal"><span class="pre">int8</span></tt> where <tt class="docutils literal"><span class="pre">321</span></tt> would be out of range. When this literal type is assigned to a new <tt class="docutils literal"><span class="pre">var</span></tt> or <tt class="docutils literal"><span class="pre">let</span></tt> variable, it's type will be resolved to just <tt class="docutils literal"><span class="pre">int</span></tt>, not <tt class="docutils literal"><span class="pre">int literal(321)</span></tt> unlike constants. A constant keeps the full <tt class="docutils literal"><span class="pre">int literal(321)</span></tt> type. Here is an example where that difference matters.</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int8</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;def&quot;</span>

<span class="Keyword">const</span> <span class="Identifier">tmp1</span> <span class="Operator">=</span> <span class="DecNumber">123</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">tmp1</span><span class="Punctuation">)</span>  <span class="Comment"># OK</span>

<span class="Keyword">let</span> <span class="Identifier">tmp2</span> <span class="Operator">=</span> <span class="DecNumber">123</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">tmp2</span><span class="Punctuation">)</span> <span class="Comment"># Error</span></pre><p>In a context with multiple overloads, the integer literal kind will always prefer the <tt class="docutils literal"><span class="pre">int</span></tt> type over all other types. If none of the overloads is of type <tt class="docutils literal"><span class="pre">int</span></tt>, then there will be an error because of ambiguity.</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">foo</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int8</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;def&quot;</span>
<span class="Identifier">foo</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span> <span class="Comment"># output: abc</span>

<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int16</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;abc&quot;</span>
<span class="Keyword">proc</span> <span class="Identifier">bar</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">int8</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="StringLit">&quot;def&quot;</span>

<span class="Identifier">bar</span><span class="Punctuation">(</span><span class="DecNumber">123</span><span class="Punctuation">)</span> <span class="Comment"># Error ambiguous call</span></pre><p>In the compiler these integer literal types are represented with the node kind <tt class="docutils literal"><span class="pre">nkIntLit</span></tt>, type kind <tt class="docutils literal"><span class="pre">tyInt</span></tt> and the member <tt class="docutils literal"><span class="pre">n</span></tt> of the type pointing back to the integer literal node in the ast containing the integer value. These are the properties that hold true for integer literal types.</p>
<pre>n.kind == nkIntLit
n.typ.kind == tyInt
n.typ.n == n</pre>
<p>Other literal types, such as <tt class="docutils literal"><span class="pre">uint literal(123)</span></tt> that would automatically convert to other integer types, but prefers to become a <tt class="docutils literal"><span class="pre">uint</span></tt> are not part of the  NimSkull language.</p>
<p>In an unchecked AST, the <tt class="docutils literal"><span class="pre">typ</span></tt> field is nil. The type checker will set the <tt class="docutils literal"><span class="pre">typ</span></tt> field accordingly to the node kind. Nodes of kind <tt class="docutils literal"><span class="pre">nkIntLit</span></tt> will get the integer literal type (e.g. <tt class="docutils literal"><span class="pre">int literal(123)</span></tt>). Nodes of kind <tt class="docutils literal"><span class="pre">nkUIntLit</span></tt> will get type <tt class="docutils literal"><span class="pre">uint</span></tt> (kind <tt class="docutils literal"><span class="pre">tyUint</span></tt>), etc.</p>
<p>This also means that it is not possible to write a literal in an unchecked AST that will after sem checking just be of type <tt class="docutils literal"><span class="pre">int</span></tt> and not implicitly convertible to other integer types. This only works for all integer types that are not <tt class="docutils literal"><span class="pre">int</span></tt>. </p>
</p>
  
  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2023-05-25 00:00:00 UTC</small>
      </div>
    </div>
  </div>
</div>
</body>
</html>
