<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>doc/debug</title>
<link rel="stylesheet" type="text/css" href="nimdoc.out.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">doc/debug</h1>
    <h1 id="compiler-debugging-guide"><center>Compiler Debugging Guide</center></h1><blockquote><p>
The process of identifying and removing errors from computer hardware or software.
</p></blockquote><p>How to debug different subsystems of the compiler using built-in tooling.</p>
<p>Each of these approaches requires building a debug or temporary compiler. Building a debug or temporary compiler is covered in the Internals documentation under the section <a class="reference external" href="intern.html">Developing the compiler</a>. Some might require additional defines as part of building the compiler and are detailed in the relevant sections below.</p>
<p>The remaining sections of this document describes how to debug various aspects of the compiler.</p>

<h2 id="debugging-defines-minus-quick-reference">Debugging Defines - Quick Reference</h2><p>(if you're new to compiler debugging skip this section to the next heading)</p>
<p>For those familiar with debugging the compiler below are quick reference tables for the various defines involved. Those new to debugging the compiler you can skim or skip these and see the following sections for details what they are and how to use them.</p>
<p><strong>Used when compiling the compiler itself</strong></p>
<table border="1" class="docutils"><tr><th>Define</th><th>Enables</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimDebugUtils</span></span></tt></td><td>Allows for semantic analysis execution tracing and more</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimDebugUnreportedErrors</span></span></tt></td><td>Enable unreported error debugging</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimVMDebugExecute</span></span></tt></td><td>Print out every instruction executed by the VM</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerStacktraceHints</span></span></tt></td><td>Add extra information (node location + kind) to some</td></tr>
</table><p><strong>Used when executing the compiler</strong></p>
<p>(most of these require a compiler built with <tt class="docutils literal"><span class="pre"><span class="Identifier">nimDebugUtils</span></span></tt>)</p>
<table border="1" class="docutils"><tr><th>Define</th><th>Enables</th></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebug</span></span></tt></td><td>Reports for localized piece of the user code</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebugCalltrace</span></span></tt></td><td>Call trace reports</td></tr>
<tr><td><tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebugTraceDir</span></span></tt></td><td>Writes call traces to the specified directory</td></tr>
</table>
<h2 id="common-operations-amp-howminustos">Common operations &amp; how-tos</h2><p><strong>Getting started with debugutils and astrepr</strong></p>
<dl class="docutils"><dt><strong>tl;dr</strong>: <tt class="docutils literal"><span class="pre"><span class="Keyword">import</span> <span class="Identifier">compiler</span><span class="Operator">/</span><span class="Identifier">utils</span><span class="Operator">/</span><span class="Identifier">astrepr</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> any value. If you</dt>
<dd>want only debug a specific section use <tt class="docutils literal"><span class="pre"><span class="Identifier">setImplicitDebugConfRef</span></span></tt> and then <tt class="docutils literal"><span class="pre"><span class="Identifier">inDebug</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> checks (paired with <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> in the code) or <tt class="docutils literal"><span class="pre"><span class="Identifier">inFile</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> (specific file name)</dd>
</dl>
<p>This section provides a short getting started guide on how to use the <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> proc from the <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span></span></tt> module and how it is integrated with <tt class="docutils literal"><span class="pre"><span class="Identifier">debugutils</span></span></tt>.</p>
<p>The main procedure for printing and debugging internal representation is <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span><span class="Operator">.</span><span class="Identifier">debug</span></span></tt>. It has several overloads that allow to print <tt class="docutils literal"><span class="pre"><span class="Identifier">PType</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Identifier">PSym</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">PNode</span></span></tt> - main types of the IR. The simplest use case is</p>
<pre class="listing"><span class="Identifier">debug</span> <span class="Identifier">node</span></pre><p>Which would print the structure of the tree. By default <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> uses implicit configuration, stored in the <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span><span class="Operator">.</span><span class="Identifier">implicitTReprConf</span></span></tt> variable. You can pass your own configuration to the <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt>, or modify the global configuration if needed. There are several preset configurations of the <tt class="docutils literal"><span class="pre"><span class="Identifier">TReprConf</span></span></tt> object, all defined the <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span></span></tt>:</p>
<pre class="listing"><span class="Identifier">debug</span> <span class="Identifier">node</span><span class="Punctuation">,</span> <span class="Identifier">onlyStructureTReprConf</span> <span class="Comment"># Print only basic structure of the tree</span>
<span class="Identifier">debug</span> <span class="Identifier">node</span><span class="Punctuation">,</span> <span class="Identifier">verboseTReprConf</span> <span class="Comment"># Print all existing fields</span>
<span class="Identifier">debug</span> <span class="Identifier">node</span><span class="Punctuation">,</span> <span class="Identifier">defaultTReprConf</span> <span class="Comment"># Starting configuration</span>
<span class="Identifier">debug</span> <span class="Identifier">node</span><span class="Punctuation">,</span> <span class="Identifier">defaultTraceReprConf</span> <span class="Comment"># Used for traced - rather compact</span></pre><p>In addition to implicit configuration of the tree printing functions there is also an implicit <tt class="docutils literal"><span class="pre"><span class="Identifier">ConfRef</span></span></tt> variable that can be set via <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span><span class="Operator">.</span><span class="Identifier">setImplicitDebugConfRef</span></span></tt>. If it is set it will be used by the <tt class="docutils literal"><span class="pre"><span class="Identifier">debug</span></span></tt> functions to access more information - for example it will now be able to resolve file index field in the <tt class="docutils literal"><span class="pre"><span class="Identifier">TLineInfo</span></span></tt>.</p>
<p>Setting this variable makes it possible to use the <tt class="docutils literal"><span class="pre"><span class="Identifier">inFile</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">inDebug</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> debugging helpers for checking whether compiler is currently processing a specific file or is in the <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">defune</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> section.</p>
<div class="admonition admonition-warning"><span class="admonition-warning-text"><b>Warning:</b></span>
The <tt class="docutils literal"><span class="pre"><span class="Identifier">inFile</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">inDebug</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> are <strong>not</strong> to be used in the final code, they implemented <strong>purely</strong> for the debug purposes.</div>
<p><strong>Do debugging only for a limited range of code</strong></p>
<p>Wrap the code range in define-undef of <tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebug</span></span></tt> and put the debugging logic in the <tt class="docutils literal"><span class="pre"><span class="Keyword">if</span> <span class="Identifier">config</span><span class="Operator">.</span><span class="Identifier">isCompilerDebug</span></span></tt> check.</p>
<p><strong>Print semantic trace for range of code</strong></p>
<p>Define <tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebug</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebugCalltrace</span></span></tt> (<tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebugCalltrace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt>). Don't forget to build the compiler with <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="Identifier">d</span><span class="Operator">=</span><span class="Identifier">nimDebugUtils</span></span></tt>.</p>
<p><strong>Print short file names in trace</strong></p>
<p>Compile test compiler with <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">filenames</span><span class="Operator">=</span><span class="Identifier">canonical</span></span></tt></p>
<p><strong>Configure in-trace printing</strong></p>
<p>Change fields in the <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span><span class="Operator">.</span><span class="Identifier">implicitCompilerTraceReprConf</span></span></tt> - it is implicitly used by the sem tracer.</p>
<p><strong>Configure semantic trace parser</strong></p>
<p>Right now some details of the configuration are coded into <tt class="docutils literal"><span class="pre"><span class="Identifier">HackController</span></span></tt> object (defined in <tt class="docutils literal"><span class="pre"><span class="Identifier">options</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt>) and it's default version - <tt class="docutils literal"><span class="pre"><span class="Identifier">defaultHackController</span></span></tt> (also defined in <tt class="docutils literal"><span class="pre"><span class="Identifier">options</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt>). For details on specific fields and uses please see the documentation comments, but high-level overview of functionality is (might be a little outdated):</p>
<table border="1" class="docutils"><tr><th>Field</th><th>Controls</th></tr>
<tr><td>semStack</td><td>Report stack trace</td></tr>
<tr><td>semTraceData</td><td>Associated data print</td></tr>
<tr><td>reportInTrace</td><td>Indentation printing</td></tr>
</table>
<h3 id="simplest-slash-all-apsects-minus-debug-helper-modules">Simplest / All Apsects - Debug Helper Modules</h3><p><a class="reference external" href="https://nim-works.github.io/nimskull/compiler/utils/astrepr.html">astrepr</a> module provides a collection of useful procedures for printing internal representation types (<tt class="docutils literal"><span class="pre">PSym</span></tt>, <tt class="docutils literal"><span class="pre">PType</span></tt> and <tt class="docutils literal"><span class="pre">PNode</span></tt>) in a readable manner. For more documentation see the module itself.</p>
<p>This is the simplest approach a bit better than <tt class="docutils literal"><span class="pre"><span class="Identifier">echo</span></span></tt> based debugging. Use the exported procs from the module, build the compiler and look at the output.</p>

<h3 id="semantic-analysis-minus-execution-tracing">Semantic Analysis - Execution Tracing</h3><p>This creates a call trace of semantic analysis functions and procedures that were invoked when compiler some code. This is useful for debugging how the compiler is interpreting a fragment of code.</p>
<p>Quick start: ******** Ensure the compiler is built with <tt class="docutils literal"><span class="pre"><span class="Identifier">nimDebugUtils</span></span></tt> defined.</p>
<ul class="simple"><li>wrap a region of user code with a define/undefine <tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebug</span></span></tt><ul class="simple"><li>or use the <tt class="docutils literal"><span class="pre"><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">nimCompilerDebugRegion</span></span></tt></li>
</ul>
</li>
<li>compile the user code with the define <tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebugCalltrace</span></span></tt></li>
<li>watch the spam</li>
</ul>

<h2 id="execution-tracing-a-fragment">Execution Tracing a Fragment</h2><p>Using a compiler built with <tt class="docutils literal"><span class="pre"><span class="Identifier">nimDebugUtils</span></span></tt> defined, compile your test file with <tt class="docutils literal"><span class="pre"><span class="program">nim</span> <span class="option">c</span> <span class="option">-d=nimCompilerDebugCalltrace</span> <span class="option">--filenames:canonical</span> <span class="Identifier">file.nim</span></span></tt> and annotate code block with the <tt class="docutils literal"><span class="pre"><span class="Identifier">nimCompilerDebug</span></span></tt> wrapper.</p>
<pre class="listing"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>
<span class="Identifier">vmTarget</span><span class="Punctuation">(</span><span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span>
<span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>You will get all the call entries traced</p>
<pre class="listing">&gt;&gt;] trace start
#0]&gt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semstmts.nim(2446, 1)
#1]  &gt; semOverloadedCallAnalyseEffects @ sem/semexprs.nim(941, 21) from sem/semexprs.nim(1133, 1)
#2]    &gt; semOverloadedCall @ sem/semcall.nim(569, 21) from sem/semexprs.nim(950, 1)
#3]      &gt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semexprs.nim(43, 1)
#4]        &gt; semTypeNode @ sem/semtypes.nim(1903, 21) from sem/semobjconstr.nim(469, 1)
#4]        &lt; semTypeNode @ sem/semtypes.nim(1903, 21) from sem/semobjconstr.nim(469, 1)
#3]      &lt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semexprs.nim(43, 1)
#2]    &lt; semOverloadedCall @ sem/semcall.nim(569, 21) from sem/semexprs.nim(950, 1)
#1]  &lt; semOverloadedCallAnalyseEffects @ sem/semexprs.nim(941, 21) from sem/semexprs.nim(1133, 1)
#0]&lt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semstmts.nim(2446, 1)
#0]&gt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semstmts.nim(2446, 1)
&lt;&lt;] trace end</pre>
<h2 id="anatomy-of-a-trace-entry">Anatomy of a Trace Entry</h2><p>Reports are formatted in the <tt class="docutils literal"><span class="pre"><span class="Identifier">cli_reporter</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt> as well (all debug reports are also transferred using regular reporting pipeline). It has a lot of information, but general parts for each call parts are:</p>
<pre class="listing">#2]    &lt; semOverloadedCall @ sem/semcall.nim(569, 21) from sem/semexprs.nim(950, 1)
^      ^ ^                   ^                             ^
|      | |                   |                             Where proc has been called from
|      | |                   Location of the `addInNimDebugUtils()` - the proc itsemf
|      | Name of the proc
|      Whether proc has been entered or exited
Depth of the traced call tree</pre>
<h2 id="missing-trace-entries">Missing Trace Entries</h2><p>Execution tracing is implemented by adding a template to each routine in the compiler manually (gasp!). Thankfully they're easy to add and quick win contributions making coverage easy to grow.</p>
<p>To add traces for a missed compiler routine insert a call to one of the <tt class="docutils literal"><span class="pre"><span class="Identifier">addInNimDebugUtils</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> overloads from <tt class="docutils literal"><span class="pre"><span class="Identifier">utils</span><span class="Operator">.</span><span class="Identifier">debugutils</span></span></tt> at the start of said routine. See the snippet below to show how tracing was added to <tt class="docutils literal"><span class="pre"><span class="Identifier">sem</span><span class="Operator">.</span><span class="Identifier">semOverloadedCall</span></span></tt>:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">semOverloadedCall</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">:</span> <span class="Identifier">PContext</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">,</span> <span class="Identifier">nOrig</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span><span class="Punctuation">,</span>
                       <span class="Identifier">filter</span><span class="Punctuation">:</span> <span class="Identifier">TSymKinds</span><span class="Punctuation">,</span> <span class="Identifier">flags</span><span class="Punctuation">:</span> <span class="Identifier">TExprFlags</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">PNode</span> <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">nosinks</span><span class="Operator">.</span><span class="Punctuation">}</span> <span class="Operator">=</span>
  <span class="Identifier">addInNimDebugUtils</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">config</span><span class="Punctuation">,</span> <span class="StringLit">&quot;semOverloadedCall&quot;</span><span class="Punctuation">)</span>
  <span class="Comment"># Rest of the code as before ...</span></pre>
<h2 id="comparingslashlogging-tracescolon-differential-debugging">Comparing/Logging Traces: Differential Debugging</h2><p>If test compiler runs with <tt class="docutils literal"><span class="pre"><span class="Operator">-</span><span class="Identifier">d</span><span class="Operator">=</span><span class="Identifier">nimCompilerDebugTraceDir</span><span class="Operator">=/</span><span class="Identifier">some</span><span class="Operator">/</span><span class="Identifier">dir</span></span></tt> option the reports stored between different sections are written into separate files in this directory. This is helpful if you want to track bugs where you have two pieces or versions of code where one works and the other doesn't. Collect traces for both and compare them to see how the compiler analysis differs between them and use that to guide your investigation. This technique is called differential debugging or sometimes differential diagnosis.</p>
<p>For example, <a class="reference external" href="https://github.com/nim-works/nimskull/issues/193">semchecked ast passed down as untyped macro argument #193</a> has two distinct cases (<tt class="docutils literal"><span class="pre"><span class="Identifier">foo1</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">foo3</span></span></tt>) whose only difference is the presence of the <tt class="docutils literal"><span class="pre"><span class="Keyword">let</span></span></tt> symbol. We can clean up the example code a little (leaving only two examples that we plan to compare):</p>
<pre class="listing"><span class="Keyword">macro</span> <span class="Identifier">check</span><span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">:</span> <span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">untyped</span> <span class="Operator">=</span> <span class="Keyword">discard</span>
<span class="Comment"># Removed the import and `treeRepr()` call because they are not</span>
<span class="Comment"># necessary in this case - we will see all the processed data</span>
<span class="Comment"># in the debug trace.</span>

<span class="Keyword">proc</span> <span class="Identifier">foo1</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">let</span> <span class="Identifier">check</span> <span class="Operator">=</span> <span class="DecNumber">123</span>
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebugCalltrace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">check</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebugCalltrace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>

<span class="Keyword">proc</span> <span class="Identifier">foo3</span><span class="Punctuation">(</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Keyword">var</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Keyword">var</span> <span class="Identifier">b</span> <span class="Operator">=</span> <span class="DecNumber">1</span>
  <span class="Comment"># this is what it should be</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebugCalltrace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span>
  <span class="Identifier">check</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span>
  <span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Punctuation">,</span> <span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebugCalltrace</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></pre><p>If we compiled the code with the following command (<tt class="docutils literal"><span class="pre"><span class="Operator">/</span><span class="Identifier">tmp</span><span class="Operator">/</span><span class="Identifier">nimtrace</span></span></tt> can any other target directory)</p>
<pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="option">--filenames:canonical</span> <span class="Identifier">-d=nimCompilerDebugTraceDir=/tmp/nimtrace</span> <span class="option">-d=nimDebugUtils</span> <span class="Identifier">file.nim</span></pre><p>We will get two large files - <tt class="docutils literal"><span class="pre"><span class="Operator">/</span><span class="Identifier">tmp</span><span class="Operator">/</span><span class="Identifier">nimtrace</span><span class="Operator">/</span><span class="DecNumber">0</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Operator">/</span><span class="Identifier">tmp</span><span class="Operator">/</span><span class="Identifier">nimtrace</span><span class="Operator">/</span><span class="DecNumber">1</span></span></tt> that contain debug trace for the first and second sections respectively. The files are quite large, so they are not included here, but the most notable part are (again, for the first and second group respectively):</p>
<pre class="listing">#0]&gt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semstmts.nim(2446, 1)
      kind:stepNodeFlagsToNode
      from flags: {}
      from node:
        Call
        0 Ident check
        1 Infix
          0 Ident ==
          1 Ident a
          2 Ident b
#1]  &gt; semIndirectOp @ sem/semexprs.nim(1025, 21) from sem/semexprs.nim(3095, 1)</pre><pre class="listing">#0]&gt; semExpr @ sem/semexprs.nim(2948, 21) from sem/semstmts.nim(2446, 1)
      kind:stepNodeFlagsToNode
      from flags: {}
      from node:
        Call
        0 Ident check
        1 Infix
          0 Ident ==
          1 Ident a
          2 Ident b
#1]  &gt; semOverloadedCallAnalyseEffects @ sem/semexprs.nim(941, 21) from sem/semexprs.nim(1133, 1)</pre><p>As you can see, the input ASTs are identical - <tt class="docutils literal"><span class="pre"><span class="Identifier">check</span><span class="Punctuation">(</span><span class="Identifier">a</span> <span class="Operator">==</span> <span class="Identifier">b</span><span class="Punctuation">)</span></span></tt>, call, infix and so on. We need to find out where exactly the calltree diverges, that is most likely going to be a location of the bug. Second group's <tt class="docutils literal"><span class="pre"><span class="Identifier">semOverloadedCall</span></span></tt> generates correct results, so we most likely need to look into the <tt class="docutils literal"><span class="pre"><span class="Identifier">semIndirectOp</span></span></tt> call here, because it does not make any sense. It calls <tt class="docutils literal"><span class="pre"><span class="Keyword">from</span> <span class="Identifier">sem</span><span class="Operator">/</span><span class="Identifier">semexprs</span><span class="Operator">.</span><span class="Identifier">nim</span><span class="Punctuation">(</span><span class="DecNumber">3095</span><span class="Punctuation">,</span> <span class="DecNumber">1</span><span class="Punctuation">)</span></span></tt>. If we go into the file and look at the surrounding code we will see that call to <tt class="docutils literal"><span class="pre"><span class="Identifier">semDirectOp</span></span></tt> is really there. <a class="reference external" href="https://github.com/nim-works/nimskull/blob/eaf1e8ac8a/compiler/sem/semexprs.nim#L3070">line 3070</a> contains call to the <tt class="docutils literal"><span class="pre"><span class="Identifier">qualifiedLookUp2</span></span></tt> call, that should've returned a <tt class="docutils literal"><span class="pre"><span class="Identifier">skMacro</span></span></tt> symbol there (branch on line <tt class="docutils literal"><span class="pre"><span class="DecNumber">3077</span></span></tt>), but this does not happen in the first case. This means we need to add the tracer call to the lookup implementation.</p>
<pre class="listing"><span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">config</span><span class="Operator">.</span><span class="Identifier">addInNimDebugUtils</span><span class="Punctuation">(</span><span class="StringLit">&quot;qualifiedLookup2&quot;</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">,</span> <span class="Identifier">result</span><span class="Punctuation">)</span></pre><p>This change results in the two more entries added to the call trace:</p>
<pre class="listing"><span class="Comment">#1]  &gt; qualifiedLookup2 @ sem/lookups.nim(732, 11) from sem/semexprs.nim(3070, 1)</span>
         <span class="Identifier">kind</span><span class="Punctuation">:</span><span class="Identifier">stepNodeToSym</span>
         <span class="Keyword">from</span> <span class="Identifier">node</span><span class="Punctuation">:</span>
           <span class="Identifier">Ident</span> <span class="Identifier">check</span>
<span class="Comment">#1]  &lt; qualifiedLookup2 @ sem/lookups.nim(732, 11) from sem/semexprs.nim(3070, 1)</span>
         <span class="Identifier">kind</span><span class="Punctuation">:</span><span class="Identifier">stepNodeToSym</span>
         <span class="Identifier">to</span> <span class="Identifier">sym</span><span class="Punctuation">:</span>
           <span class="Keyword">Let</span>
             <span class="Identifier">typ</span><span class="Punctuation">:</span>   <span class="Identifier">Int</span> <span class="Identifier">sk</span><span class="Punctuation">:</span><span class="Keyword">Type</span>
             <span class="Identifier">owner</span><span class="Punctuation">:</span>  <span class="Identifier">kind</span><span class="Punctuation">:</span><span class="Identifier">skProc</span> <span class="Identifier">name</span><span class="Punctuation">:</span><span class="Identifier">foo1</span></pre><pre class="listing"><span class="Comment">#1]  &gt; qualifiedLookup2 @ sem/lookups.nim(732, 11) from sem/semexprs.nim(3070, 1)</span>
         <span class="Identifier">kind</span><span class="Punctuation">:</span><span class="Identifier">stepNodeToSym</span>
         <span class="Keyword">from</span> <span class="Identifier">node</span><span class="Punctuation">:</span>
           <span class="Identifier">Ident</span> <span class="Identifier">check</span>
<span class="Comment">#1]  &lt; qualifiedLookup2 @ sem/lookups.nim(732, 11) from sem/semexprs.nim(3070, 1)</span>
         <span class="Identifier">kind</span><span class="Punctuation">:</span><span class="Identifier">stepNodeToSym</span>
         <span class="Identifier">to</span> <span class="Identifier">sym</span><span class="Punctuation">:</span>
           <span class="Keyword">Macro</span>
             <span class="Identifier">flags</span><span class="Punctuation">:</span> <span class="Punctuation">{</span><span class="Identifier">Used</span><span class="Punctuation">,</span> <span class="Identifier">Global</span><span class="Punctuation">}</span>
             <span class="Identifier">offset</span><span class="Punctuation">:</span><span class="DecNumber">2</span>
             <span class="Identifier">typ</span><span class="Punctuation">:</span>   <span class="Keyword">Proc</span> <span class="Punctuation">(</span><span class="Identifier">args</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
             <span class="Identifier">owner</span><span class="Punctuation">:</span>  <span class="Identifier">kind</span><span class="Punctuation">:</span><span class="Identifier">skModule</span> <span class="Identifier">name</span><span class="Punctuation">:</span><span class="Identifier">file</span></pre><p>As you can see now, the return values of this procedure are different here. We have successfully localized the bug from 'whole compiler' to a specific procedure.</p>
<hr />
<div class="admonition admonition-info"><span class="admonition-info-text"><b>Tip:</b></span>
It is perfeclty fine to add new debug trace options or remove some of the existing ones if you think it is necessary for you to better understand what is going on in the compiler.</div>
<div class="admonition admonition-info"><span class="admonition-info-text"><b>Tip:</b></span>
<p>Sometimes it is necessary to print processed nodes for a specific part of the compiler procedure, but it runs multiple times on the code that does not show any issues, clobbering the final output and making it harder to figure out what was wrong.</p>
<p>In that case you can wrap problematic (input) code with <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">undef</span><span class="Punctuation">(</span><span class="Identifier">nimCompilerDebug</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt> sections, and then check for the symbols definition using <tt class="docutils literal"><span class="pre"><span class="Identifier">debugutils</span><span class="Operator">.</span><span class="Identifier">isCompilerDebug</span></span></tt>, to filter out unnecessary noise.</p>
<pre class="listing"><span class="Keyword">if</span> <span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">config</span><span class="Operator">.</span><span class="Identifier">isCompilerDebug</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">:</span>
  <span class="Comment"># Check if we are in the `{.defined(nimCompilerDebug).}` section</span>
  
  <span class="Comment"># Call any debugging logic you can think of</span>
  <span class="Identifier">echo</span> <span class="Identifier">c</span><span class="Operator">.</span><span class="Identifier">config</span><span class="Operator">.</span><span class="Identifier">treeRepr</span><span class="Punctuation">(</span><span class="Identifier">result</span><span class="Punctuation">,</span> <span class="Identifier">maxPath</span> <span class="Operator">=</span> <span class="DecNumber">1</span><span class="Punctuation">)</span></pre><p>Alternatively, if you need to filter out node on the file/line location basis, you can use <tt class="docutils literal"><span class="pre"><span class="Identifier">inFile</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">inLines</span></span></tt> procs defined in the <tt class="docutils literal"><span class="pre"><span class="Identifier">astrepr</span></span></tt>. Note that both of them are only for debug purposes, and should not stay in the final code.</p>
</div>
<div class="admonition admonition-warning"><span class="admonition-warning-text"><b>Warning:</b></span>
Specific details of processing for modules in presence of multiple compile-time statements (such as <tt class="docutils literal"><span class="pre"><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">define</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Punctuation">}</span></span></tt>) is yet to be properly specified and tested, so when used for <strong>cross-module</strong> semantic issues (god help you if you ever find yourself facing something like this) it might inhibit unexpected behavior.</div>

<h3 id="mir-input-and-output">MIR Input and Output</h3><p>For debugging issues related to the MIR but also code-generator issues in general, one can print the input and output to the MIR canonicalization step plus the corresponding <tt class="docutils literal"><span class="pre"><span class="Identifier">PNode</span></span></tt>-AST output.</p>
<p>To print the <tt class="docutils literal"><span class="pre"><span class="Identifier">PNode</span></span></tt>-AST that reaches <tt class="docutils literal"><span class="pre"><span class="Identifier">mirgen</span></span></tt>, <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">define</span><span class="Punctuation">:</span><span class="Identifier">nimShowMirInput</span><span class="Operator">=</span><span class="Identifier">name</span></span></tt> is used. This will print out the <tt class="docutils literal"><span class="pre"><span class="Identifier">PNode</span></span></tt>-AST of all procedures and modules of which the name is equal to the specified <tt class="docutils literal"><span class="pre"><span class="Identifier">name</span></span></tt> in the console. Because of how dead-code-elimination works, only the AST of alive procedures (i.e. used ones) is printed. If a procedure is used at both compile- and run-time, it will be printed twice.</p>
<p>To print the generated MIR code for a procedure, <tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">define</span><span class="Punctuation">:</span><span class="Identifier">nimShowMir</span><span class="Operator">=</span><span class="Identifier">name</span></span></tt> can be used. The same limitation as for <tt class="docutils literal"><span class="pre"><span class="Identifier">nimShowMirInput</span></span></tt> apply.</p>
<p><tt class="docutils literal"><span class="pre"><span class="Operator">--</span><span class="Identifier">define</span><span class="Punctuation">:</span><span class="Identifier">nimShowMirOutput</span><span class="Operator">=</span><span class="Identifier">name</span></span></tt> prints the <tt class="docutils literal"><span class="pre"><span class="Identifier">CgNode</span></span></tt>-IR that is output by <tt class="docutils literal"><span class="pre"><span class="Identifier">cgirgen</span></span></tt>. This is IR that the code generators operate on.</p>
<p>While all of the defines listed above can be used simultaneously, only a single occurrence of each is considered. Each further occurrence will override the respective name.</p>

<h3 id="vm-codegen-and-execution">VM Codegen and Execution</h3><p>For echoing the VM bytecode generated for compile-time procedures and macros, <tt class="docutils literal"><span class="pre option">--define:expandVmListing=vmTarget</span></tt> can be passed to the compiler (no special build of the compiler is required). The bytecode for all routines of which the name is <tt class="docutils literal"><span class="pre"><span class="Identifier">vmTarget</span></span></tt> is then echoed to the standard output. Leaving <tt class="docutils literal"><span class="pre"><span class="Identifier">vmTarget</span></span></tt> empty enables echoing for <em>all</em> VM bytecode that is generated as part of compile-time execution.</p>
<p>For example (generated listing might not match exactly)</p>
<pre class="listing"><span class="Keyword">type</span>
  <span class="Identifier">Obj</span> <span class="Operator">=</span> <span class="Keyword">object</span>
    <span class="Identifier">charField</span><span class="Punctuation">:</span> <span class="Identifier">char</span>
    <span class="Identifier">intField</span><span class="Punctuation">:</span> <span class="Identifier">int</span>

<span class="Keyword">proc</span> <span class="Identifier">vmTarget</span><span class="Punctuation">(</span><span class="Identifier">arg</span><span class="Punctuation">:</span> <span class="Identifier">Obj</span><span class="Punctuation">)</span> <span class="Operator">=</span>
  <span class="Identifier">echo</span> <span class="Identifier">arg</span><span class="Operator">.</span><span class="Identifier">charField</span><span class="Operator">.</span><span class="Identifier">int</span> <span class="Operator">+</span> <span class="Identifier">arg</span><span class="Operator">.</span><span class="Identifier">intField</span>

<span class="Keyword">static</span><span class="Punctuation">:</span>
  <span class="Identifier">vmTarget</span><span class="Punctuation">(</span><span class="Identifier">Obj</span><span class="Punctuation">(</span><span class="Punctuation">)</span><span class="Punctuation">)</span></pre><pre class="listing"><span class="program">nim</span> <span class="option">c</span> <span class="option">--filenames:canonical</span> <span class="option">--define:expandVmListing=vmTarget</span> <span class="Identifier">file.nim</span></pre><pre class="listing">Code listing for 'vmTarget' file.nim(6, 6)
  
  LdConst      r3     $     1279                system.nim(2005, 30)
  LdObj        r6     r1     r0                 file.nim(7, 11)
  NodeToReg    r5     r6     r0                 file.nim(7, 11)
  Conv         r6     r5     int   char         file.nim(7, 21)
  LdObj        r7     r1     r1                 file.nim(7, 31)
  NodeToReg    r5     r7     r0                 file.nim(7, 31)
  AddInt       r4     r6     r5                 file.nim(7, 26)
  IndCallAsgn  r2     r3     #2                 file.nim(7, 26)
  Echo         r2     r1     r0                 file.nim(7, 26)
  Ret          r0     r0     r0                 file.nim(7, 8)
  Eof          r0     r0     r0                 file.nim(7, 8)</pre>


    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2023-10-20 00:00:00 UTC</small>
      </div>
    </div>
  </div>
</div>
</body>
</html>
